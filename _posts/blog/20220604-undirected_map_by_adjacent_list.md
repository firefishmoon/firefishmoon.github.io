---
layout: post
title: 一种邻接表的实现方式
categories: Blog
description: 一种邻接表的实现方式
keywords: 数据结构, 无向图
---

# 一种邻接表的实现方式

  今天在云风的blog上看到了他更新的一篇文章：《用邻接表实现无向图》，在文中描述的邻接表的实现方式我以前并没有见过，沉思良久无果，接着再在网上搜索邻接表，也没发现这种实现方式，再翻阅了几本手上的数据结构书籍，也没有类似的实现方式。只好继续一字一字看他的文字，再在纸上用笔推算，大概推出了个所以然，所以赶紧用文字记录下思路。

  例如有下面这张无向图：

![](/images/posts/blog/a_undirected_map.png)

图中有5个节点，6条边，每个节点有个数字id。

传统的邻接表的表示方式为：

```
1 : 2 -> 5 -> 4
2 : 1 -> 5
3 : 4
4 : 1 -> 3 -> 5
5 : 1 -> 2 -> 4
```
每一个节点后面用链表来存储与之相连接的相邻节点，链表中相邻节点的顺序可以任意调换。

图的一个重要操作就是需要从一个节点遍历它所有的关联的边。

如果我们需要遍历节点1的所有边，只需要遍历节点1存储的链表，就可以得到3条边：
```
节点1和节点2组成的边
节点1和节点5组成的边
节点1和节点4组成的边
```
这种方式下,边用代码表示为：

```
struct Edge {
    int nodeIndex;   // 相邻的节点在Graphy中的node数组中的索引
    Edge *next;   // 下一条边
};
```
节点和图的代码表示为：
```
struct Node {
    int nodeid;
    Edge *next;
};

struct Graphy {
    Node node[MAX_NODE];  
};
```
所以在上面实现中，用到的数据结构为数组+链表

在云风的blog中，他贴出的边的定义为：
```
struct edge {
  uint16_t endpoint[2];
  uint16_t left;
  uint16_t right;
} ;
```
其中left, right为两个节点id，每个边连接了两个节点，所以可以用两个节点id来定义一个节点，较小id存储在left，较大的id存储在right。

left，right比较好理解，endpoint就不太好理解了，文中给出的说明是：
> 两个链表指向两个端点的边集合

意思就是endpoint里面存的也是边，endpoint[0]里存的是left的边集合，endpoint[1]里存的是right的边集合。endpoint又只是个uint16_t的值，只可能存储的是一个索引，所以endpoint里存储的是下一个edge的索引。再推测出此方式保存的是个edge数组。

经过一番推算,还是用上面的无向图，得到以下的edge数组：
```
[0] (1, 2), 4, 1
[1] (2, 5), 1, 2
[2] (4, 5), 3, 5
[3] (3, 4), 3, 4
[4] (1, 4), 5, 4
[5] (1, 5), 5, 5
```
数组生成的顺序为：

1. 先遍历图中所有的边(遍历顺序随意)，得到一个大小为6的数组，并按nodeid填充left, right值。这一步得到
   ```
    [0] (1, 2), x1, x2
    [1] (2, 5), x3, x4
    [2] (4, 5), x5, x6
    [3] (3, 4), x7, x8
    [4] (1, 4), x9, x10
    [5] (1, 5), x11, x12
   ```
   x1，x2...，x12 表示endpoint的值还未知。
2. 遍历数组，逐个求两个x的值。例如第一组\[0](1, 2), x1, x2。x1为下一个指向nodeid为1的边的索引，向下遍历数组，看下一次出现nodeid为1时索引值为多少，可以看到下一次出现1为\[4](1,4),x9,x10 ，索引值为4，所以x1为4。x2为下一个指向nodeid为2的边的索引，可以看到下一次出现2为\[1](2,5),x3,x4 ，索引值为1，所以x2为1。如果往下没有了，则把x值设为自己这条边的索引。这样依次可以求出各个x的值。
3. 还得存储一个每个节点第一次出现的边索引，以上为：
   ```
   1:0
   2:0
   3:3
   4:2
   5:1
   ```

有了这两个数组，我们也可以遍历每个节点所关联的边。

比如，遍历节点1，首先从下面表中拿到1一次出现的边索引为0，得到(1,2),4,1。再看下一个对应的边索引是4，得到(1, 4), 5, 4。在看下一个索引为5，得到(1, 5), 5, 5。下一个为5，和当前边的索引值相同，遍历停止。就到了节点1的三条边，(1,2)  (1,4)  (1,5)

这种实现方式不是那么的直观，而且存储占用的字节数也大于传统的实现方式。但是云风在blog中优化了这个数组结构，压缩了1/4大小，这样就比传统方式占用内存要小了。具体实现我也还没看懂，以后再说。crying......

2022/6/4